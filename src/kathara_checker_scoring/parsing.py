import csv
import json
from pathlib import Path
import re
from typing import Any, Iterable

from kathara_checker_scoring.models import CheckGroup, GroupCategory, GroupType, LabResultRecord, ScoringConfig


def _parse_field(data: dict, data_name: str, field_name: str, expected_types: type | tuple) -> Any:
    if field_name not in data:
        raise ValueError(f"Parsing '{data_name}' failed: missing '{field_name}'")
    value = data[field_name]
    if not isinstance(value, expected_types):
        types = (
            "/".join(t.__name__ for t in expected_types)
            if isinstance(expected_types, tuple)
            else expected_types.__name__
        )
        raise ValueError(
            f"Parsing '{data_name}' failed: '{field_name}' must be of type {types}, got {type(value).__name__}"
        )
    return value


def _parse_positive_field(data: dict, data_name: str, field_name: str) -> int | float:
    raw = _parse_field(data, data_name, field_name, (int, float))
    if raw < 0:
        raise ValueError(f"Parsing '{data_name}' failed: '{field_name}' must be non-negative, got {raw}")
    return raw


def _parse_regex_field(data: dict, data_name: str, field_name: str) -> re.Pattern:
    raw = _parse_field(data, data_name, field_name, str)
    try:
        return re.compile(raw)
    except re.error as e:
        raise ValueError(f"Parsing '{data_name}' failed: invalid regex '{raw}': {e}")


def _parse_choice_field(data: dict, data_name: str, field_name: str, possible_values: Iterable[Any]) -> Any:
    raw = _parse_field(data, data_name, field_name, str)
    if raw not in possible_values:
        raise ValueError(f"Parsing '{data_name}' failed: '{field_name}' must be one of {possible_values}")
    return raw


def _parse_dict_list(data: dict, data_name: str, field_name: str) -> list[dict]:
    raw = _parse_field(data, data_name, field_name, list)
    if any(not isinstance(x, dict) for x in raw):
        raise ValueError(f"Parsing '{data_name}' failed: '{field_name}' must be a list of objects")
    return raw


def parse_config(data: dict) -> ScoringConfig:
    """
    Parses the configuration from a dictionary containing basic raw types.
    ValueError is thrown when an invalid format is encountered.
    """

    def _parse_group(data: dict, category: GroupCategory) -> CheckGroup:
        name = _parse_field(data, f"{category.name} / group", "name", str)
        data_name = f"{category.name} / {name}"
        return CheckGroup(
            name=name,
            type=GroupType(_parse_choice_field(data, data_name, "type", [str(x) for x in GroupType])),
            description_regex=_parse_regex_field(data, data_name, "description_regex"),
            points=_parse_positive_field(data, data_name, "points"),
            category=category,
        )

    def _parse_category(data: dict) -> GroupCategory:
        name = _parse_field(data, "category", "name", str)
        category = GroupCategory(
            name=name,
            points_multiplier=_parse_positive_field(data, name, "points_multiplier"),
            groups=[],
        )
        for group_dict in _parse_dict_list(data, name, "groups"):
            category.groups.append(_parse_group(group_dict, category))
        return category

    categories_list = _parse_dict_list(data, "config root", "categories")
    return ScoringConfig(categories=[_parse_category(x) for x in categories_list])


def load_config(path: Path) -> ScoringConfig:
    """
    Loads the configuration from the specified JSON file path.
    ValueError is thrown when an invalid format is encountered.
    """
    if not path.exists():
        raise ValueError(f"The specified file ({path}) does not exist")
    with path.open(encoding="utf-8") as f:
        return parse_config(json.load(f))


def load_result_all_csv(path: Path) -> list[LabResultRecord]:
    """
    Loads the executed check logs (records) generated by kathara-lab-checker.
    """
    if not path.exists():
        raise ValueError(f"The specified file ({path}) does not exist")
    with path.open(newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        return [
            LabResultRecord(
                description=row["Test Description"].strip(),
                passed=row["Passed"].strip().lower() == "true",
                reason=row["Reason"].strip(),
            )
            for row in reader
        ]
